#!/bin/bash


function usage_and_die() {
    {
        echo 'Extracts kernel parameters from /proc/cmdline. Only run this on trusted files!'
        echo 'To prevent erroneous expansion, this will fail if /proc/cmdline has a $ in it.'
        echo 'If you want to expand cmdlines that have a $, use a real language (not bash).'
        echo 'If parameter is absent, return DEFAULT_VALUE (if set) or exit with status 1.'
        echo "Usage: $0 PARAMETER [DEFAULT_VALUE]"
    } >&2
    exit 1
}

# Emits a series of \0-delimited param=value entries to stdout.
function parse() {
    local to_parse="$1"

    local in_sq_context=false
    local in_dq_context=false
    local esc=false
    local tail=0

    for ((head=0; head < "${#to_parse}"; head++)); do
        char="${to_parse:$head:1}"

        if [[ "$esc" == "true" ]]; then # char is escaped, skipping.
            esc=false
            continue
        fi

        zap_char=

        case "$char" in
            " "|"	"|"\n")
                if [[ "$in_sq_context" == "false" \
                    && "$in_dq_context" == "false" ]]; then
                    # This is bare whitespace. Cut here.
                    printf '%s\0' "${to_parse:$tail:$((head-tail))}"
                    ((tail=head+1))
                fi
                ;;
            "'")
                if [[ "$in_dq_context" == "true" ]]; then
                    # This is a ' within doublequotes. Don't parse it.
                    continue
                elif [[ "$in_sq_context" == "true" ]]; then
                    # This is a closing quote.
                    in_sq_context=false
                    zap_char=y
                else
                    # This is an opening quote.
                    in_sq_context=true
                    zap_char=y
                fi
                ;;
            '"')
                if [[ "$in_sq_context" == "true" ]]; then
                    # This is a " within singlequotes. Don't parse it.
                    continue
                elif [[ "$in_dq_context" == "true" ]]; then
                    # This is a closing quote.
                    in_dq_context=false
                    zap_char=y
                else
                    # This is an opening quote.
                    in_dq_context=true
                    zap_char=y
                fi
                ;;
            '\')
                esc=true
                zap_char=y
                ;;
        esac
        if [[ -n "$zap_char" ]]; then
            to_parse="${to_parse:0:$head}${to_parse:$((head+1))}"
            ((head--))
        fi
    done

    printf '%s\0' "${to_parse:$tail}"
}

function lookup() {
    declare -A _parammap

    mapfile -d '' kparams
    for p in "${kparams[@]}"; do
        k="${p%%=*}"
        v="${p#*=}"
        [[ -z "$k" ]] && continue # empty entry; skip it
        _parammap[$k]="$v"
    done

    # If not present, then figure out if we should use a default or fail.
    if [[ ! -v "_parammap[$1]" ]]; then
        if [[ "$#" == 2 ]]; then
            echo "$2"
            exit 0
        else
            exit 1
        fi
    fi

    echo "${_parammap[$1]}"
}

if [[ "$#" < 1 || "$#" > 2 ]]; then
    usage_and_die
fi

__CMDLINE="${TESTONLY_ALTERNATIVE_CMDLINE:-/proc/cmdline}"
TO_PARSE="$(<"$__CMDLINE")"
parse "$TO_PARSE" | lookup "$@"
