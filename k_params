#!/bin/bash


function usage_and_die() {
    {
        echo 'Extracts kernel parameters from /proc/cmdline. Only run this on trusted files!'
        echo 'To prevent erroneous expansion, this will fail if /proc/cmdline has a $ in it.'
        echo 'If you want to expand cmdlines that have a $, use a real language (not bash).'
        echo 'If parameter is absent, return DEFAULT_VALUE (if set) or exit with status 1.'
        echo "Usage: $0 PARAMETER [DEFAULT_VALUE]"
    } >&2
    exit 1
}

function try() {
    # This is bare whitespace. Cut here.
    to_try="$1"
    want="$2"
    name="${to_try%%=*}"
    value="${to_try#*=}"
    if [[ "$name" == "$want" ]]; then
        echo "$value"
        exit 0
    fi
    return 1
}


# Emits a series of \0-delimited param=value entries to stdout.
function parse() {
    local to_parse="$1"

    local in_sq_context=false
    local in_dq_context=false
    local esc=false
    local tail=0

    for ((head=0; head < "${#to_parse}"; head++)); do
        char="${to_parse:$head:1}"

        if [[ "$esc" == "true" ]]; then # char is escaped, skipping.
            esc=false
            continue
        fi

        zap_char=

        case "$char" in
            " "|"	"|"\n")
                if [[ "$in_sq_context" == "false" \
                    && "$in_dq_context" == "false" ]]; then
                    # This is bare whitespace. Cut here.
                    try "${to_parse:$tail:$((head-tail))}" "$2"
                    name="${whole%%=*}"
                    value="${whole#*=}"
                    if [[ "$whole" == "$2" ]]; then
                        echo "$value"
                        exit 0
                    fi
                    # Haven't found it yet; mark our tail here and keep going.
                    ((tail=head+1))
                fi
                ;;
            "'")
                if [[ "$in_dq_context" == "true" ]]; then
                    # This is a ' within doublequotes. Don't parse it.
                    continue
                elif [[ "$in_sq_context" == "true" ]]; then
                    # This is a closing quote.
                    in_sq_context=false
                    zap_char=y
                else
                    # This is an opening quote.
                    in_sq_context=true
                    zap_char=y
                fi
                ;;
            '"')
                if [[ "$in_sq_context" == "true" ]]; then
                    # This is a " within singlequotes. Don't parse it.
                    continue
                elif [[ "$in_dq_context" == "true" ]]; then
                    # This is a closing quote.
                    in_dq_context=false
                    zap_char=y
                else
                    # This is an opening quote.
                    in_dq_context=true
                    zap_char=y
                fi
                ;;
            '\')
                esc=true
                zap_char=y
                ;;
        esac
        if [[ -n "$zap_char" ]]; then
            to_parse="${to_parse:0:$head}${to_parse:$((head+1))}"
            ((head--))
        fi
    done

    # Let's try whatever we've got left.
    if ! try "${to_parse:$tail}" "$2" && [[ "$#" == 3 ]]; then
        echo "$3"
        exit 0
    else
        exit 1
    fi
}

if [[ "$#" < 1 || "$#" > 2 ]]; then
    usage_and_die
fi

__CMDLINE="${TESTONLY_ALTERNATIVE_CMDLINE:-/proc/cmdline}"
TO_PARSE="$(<"$__CMDLINE")"
parse "$TO_PARSE" "$@"
