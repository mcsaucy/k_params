#!/bin/bash


function usage_and_die() {
    {
        echo 'Extracts kernel parameters from /proc/cmdline. Only run this on trusted files!'
        echo 'To prevent erroneous expansion, this will fail if /proc/cmdline has a $ in it.'
        echo 'If you want to expand cmdlines that have a $, use a real language (not bash).'
        echo 'If parameter is absent, return DEFAULT_VALUE (if set) or exit with status 1.'
        echo "Usage: $0 PARAMETER [DEFAULT_VALUE]"
    } >&2
    exit 1
}

if [[ "$#" < 1 || "$#" > 2 ]]; then
    usage_and_die
fi

__CMDLINE="${TESTONLY_ALTERNATIVE_CMDLINE:-/proc/cmdline}"

if grep -q '\$' "$__CMDLINE"; then
    echo "$__CMDLINE has a \$; refusing to expand to prevent env leakage." >&2
    exit 2
fi

declare -a _allparams
declare -A _parammap

eval "_allparams=( $(cat "$__CMDLINE") )"

eval "_allparams=( $(cat "$__CMDLINE") )"
for p in "${_allparams[@]}"; do
    k="${p%%=*}"
    v="${p#*=}"
    _parammap["$k"]="$v"
done

# If not present, then figure out if we should use a default or fail.
if [[ ${_parammap[$1]+present} != "present" ]]; then
    if [[ "$#" == 2 ]]; then
        echo "$2"
        exit 0
    else
        exit 1
    fi
fi

echo "${_parammap[$1]}"
